searchState.loadedDescShard("flow", 0, "This crate manage dataflow in Greptime, including adapter, …\nFlow config that exists both in standalone&amp;distributed mode\nFlowNodeManager manages the state of all tasks in the flow …\nArc-ed FlowNodeManager, cheaper to clone\n<code>FlownodeInstance</code> Builder\nThe flownode server instance.\nOptions for flow node\nfor getting data from source and sending results to sink …\nBuild and Compute the dataflow\nDatafusion optimizer for flow plan\nError definition for flow module\nfor declare Expression in dataflow, including map, reduce, …\nLock for flushing, will be <code>read</code> by <code>handle_inserts</code> and <code>write</code>…\nSend heartbeat from flownode to metasrv\nonly used for health check\nSome of the metrics used in the flow module.\ncontains mapping from table name to global id, and table …\nThis module contain basic definition for dataflow’s plan …\nThe query engine that will be used to parse the query and …\nContains all refill tasks\nbasically a wrapper around the <code>datatype</code> crate for basic …\nImplementation of grpc service for flow node\nreceive a oneshot sender to send state size report\nreceive a oneshot sender to send state size report\nGetting table name and table schema from table info manager\nTransform Substrait into execution plan\nutilities for managing state of dataflow execution\nThe handler to the worker that will run the dataflow which …\nThe selector to select a worker to run the dataflow\nThe arguments to create a flow in <code>FlowWorkerManager</code>.\nFlow config that exists both in standalone&amp;distributed mode\nFlowId is a unique identifier for a flow task\nFlowTickManager is a manager for flow tick, which trakc …\nFlowNodeManager manages the state of all tasks in the flow …\nArc-ed FlowNodeManager, cheaper to clone\nOptions for flow node\nadd a worker handler to manager, meaning this …\nreturn (primary keys, schema and if the table have a …\nCreate and start refill flow tasks in background\nReturn task id if a new task is created, otherwise return …\nCreate a series of tasks to refill flow\nCreate table from given schema(will adjust to add auto …\nFetch table schema and primary key from table info source, …\nimpl <code>FlowNode</code> trait for FlowNodeManager so standalone can …\nLock for flushing, will be <code>read</code> by <code>handle_inserts</code> and <code>write</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate writeback request for all sink table\nGet a worker handle for creating flow, using round robin …\nsend write request to related source sender\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nlog all flow errors\nCreate <strong>without</strong> setting <code>frontend_invoker</code>\nCreate a flownode manager with one worker\nNode context, prone to change with every incoming requests\ncontains mapping from table name to global id, and table …\nparse expr like “ts &lt;= now() - interval ‘5 m’”\nThe query engine that will be used to parse the query and …\nThis module contains the refill flow task, which is used …\nContains all refill tasks\nremove a flow by it’s id\nTrigger dataflow running, and then send writeback request …\nRun all available subgraph in the flow node This will try …\nrun in common_runtime background runtime\nReturn the number of requests it made\nset frontend invoker\nThe starting instant of the flow, used with <code>start_timestamp</code>…\nStart state report handler, which will receive a sender …\nThe timestamp when the flow started\nStarting to refill flows, if any error occurs, will …\nreceive a oneshot sender to send state size report\nsubmit a create table ddl\nGetting table name and table schema from table info manager\nHow to query table information from database\nReturn the current timestamp in milliseconds\nTry fetch table with adjusted schema(added auto column if …\nFor single-thread flow worker\nThe handler to the worker that will run the dataflow which …\nThe selector to select a worker to run the dataflow\nSimple helper enum for fetching value from row with …\nPanic if idx is out of bound\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nreturn a function to convert <code>crate::error::Error</code> to …\nA context that holds the information of the dataflow\nA tri-directional map that maps table name, table id, and …\nmax number of iterations to try flush send buf\na simple broadcast sender with backpressure, bounded …\nadd flow plan to worker context\ntry add source sender, if already exist, do nothing\nAssign a global id to a table, if already assigned, return …\nmapping from task to sink table, useful for sending data …\nflush all sender’s buf\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a new global id\nmapping source table to task, and sink table to task in …\nremove flow from worker context\nreturn number of rows it actual send(including what’s in …\nsend record batch\nreturn number of rows it actual send(including what’s in …\nbroadcast receiver for sink table, there should only be …\nbroadcast sender for source table, any incoming write …\nmapping from source table to tasks, useful for schedule …\nRetrieves a GlobalId and table schema representing a table …\nAll the tables that have been registered in the worker\ncan query the schema of the table source, from metasrv …\nsend as many as possible rows from send buf until send buf …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nparse duration and return ttl, currently only support time …\na simple pratt parser\nparse a number with optional sign\nTask is finished\nTask is not started\nQuery stream of RefillTask, simply wrap RecordBatches and …\nTask to refill flow with given table id and a time range\nTask is running\nRefill task state\nQuery with “select * from table WHERE time &gt;= …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ncheck if task is finished\nStart running the task in background, non-blocking\nvalidate that incoming batch’s schema is the same as …\nTable source but for flow, provide table schema by table …\nmanaged table source information, query from table info …\nTable description, include relation desc and default …\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the table haven’t been created in database, the …\nquery metasrv about the <code>TableInfoValue</code> and table id\nquery metasrv about the table name and table id\nGet the time index column from table id\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the table schema by table name\nfor query <code>TableId -&gt; TableName</code> mapping\nconvert <code>ColumnSchema</code> lists to it’s corresponding proto …\nConvert <code>RelationDesc</code> to <code>ColumnSchema</code> list, if the column …\nActiveDataflowState is a wrapper around <code>Hydroflow</code> and …\nTrigger the worker to run, useful after input buffer is …\nThe actual worker that does the work and contain active …\nOptionally returns references to the inner fields if this …\nOptionally returns references to the inner fields if this …\nOptionally returns mutable references to the inner fields …\nOptionally returns mutable references to the inner fields …\nOptionally returns references to the inner fields if this …\nOptionally returns references to the inner fields if this …\nOptionally returns mutable references to the inner fields …\nOptionally returns mutable references to the inner fields …\nOptionally returns references to the inner fields if this …\nOptionally returns mutable references to the inner fields …\nOptionally returns references to the inner fields if this …\nOptionally returns references to the inner fields if this …\nOptionally returns mutable references to the inner fields …\nOptionally returns mutable references to the inner fields …\nOptionally returns references to the inner fields if this …\nOptionally returns mutable references to the inner fields …\ncall without response\ncall with response\ncreate task, return task id\nCreate both worker(<code>!Send</code>) and worker handle(<code>Send + Sync</code>)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nhandle request, return response if any, Err if receive …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner fields if this is a <code>Request::ContainTask</code>…\nReturns the inner fields if this is a <code>Response::ContainTask</code>…\nReturns the inner fields if this is a <code>Request::Create</code>, …\nReturns the inner fields if this is a <code>Response::Create</code>, …\nReturns the inner fields if this is a …\nReturns the inner fields if this is a <code>Request::Remove</code>, …\nReturns the inner fields if this is a <code>Response::Remove</code>, …\nReturns the inner fields if this is a <code>Request::RunAvail</code>, …\nReturns true if this is a <code>Request::ContainTask</code>, otherwise …\nReturns true if this is a <code>Response::ContainTask</code>, otherwise …\nReturns true if this is a <code>Request::Create</code>, otherwise false\nReturns true if this is a <code>Response::Create</code>, otherwise false\nReturns true if this is a <code>Request::QueryStateSize</code>, …\nReturns true if this is a <code>Response::QueryStateSize</code>, …\nReturns true if this is a <code>Request::Remove</code>, otherwise false\nReturns true if this is a <code>Response::Remove</code>, otherwise false\nReturns true if this is a <code>Request::RunAvail</code>, otherwise …\nReturns true if this is a <code>Response::RunAvail</code>, otherwise …\nReturns true if this is a <code>Request::Shutdown</code>, otherwise …\nCreate a new render context, assigned with given global id\nremove task, return task id\nremove task, return true if a task is removed\nRun the worker, blocking, until shutdown signal is received\nRun all available subgraph\ntrigger running the worker, will not block, and will run …\nrun with tick acquired from tick manager(usually means …\nshutdown the worker\nTask states\neach flow tasks’ state size\nIn this file, <code>render</code> means convert a static <code>Plan</code> into a …\nThe Context for build a Operator with id of <code>GlobalId</code>\nThe Common argument for all <code>Subgraph</code> in the render process\nContrast to it name, it’s for adding distinct input for …\nEval <code>Let</code> operator, useful for assigning a value to a local …\nEval <code>Let</code> operator, useful for assigning a value to a local …\nReturns the argument unchanged.\nReturns the argument unchanged.\na list of all collections being used in the operator\na list of all collections being used in the operator\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nused by <code>Get</code>/<code>Let</code> Plan for getting/setting local variables\nused by <code>Get</code>/<code>Let</code> Plan for getting/setting local variables\nrender Constant, take all rows that have a timestamp not …\nrender Constant, take all rows that have a timestamp not …\nrender MapFilterProject, will only emit the <code>rows</code> once. …\nLike <code>render_mfp</code> but in batch mode\nInterpret plan to dataflow and prepare them for execution\nLike <code>render_plan</code> but in Batch Mode\nrender <code>Plan::Reduce</code> into executable dataflow\nLike <code>render_reduce</code>, but for batch mode, and only barebone …\nRender a source which comes from brocast channel into the …\nsimply send the batch to downstream, without fancy …\nSource and Sink for the dataflow\nThe core of evaluating MFP operator, given a MFP and a …\nAccumulate the output of aggregation functions\nAll arrange(aka state) used in reduce operator\nThe distinct input arrangement for accumulable reduce plan …\nEval distinct aggregate functions with distinct input …\nreturn distinct rows(distinct by row’s key) from the …\nEval simple aggregate functions with no distinct input\nReturns the argument unchanged.\nReturns the argument unchanged.\nconvert a list of accumulators to a vector of values with …\nConvert a value to a list of slice index\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nreturn (accums, output)\nThe output arrange of reduce operator\neval accumulable reduce plan by eval aggregate function …\neval distinct reduce plan, output the distinct, and update …\nreduce subgraph, reduce the input data into a single row …\nsplit a row into key and val by evaluate the key and val …\neval distinct reduce plan, output the distinct, and update …\ninput/output of a dataflow One <code>ComputeState</code> manage the …\nsave all used arrange in this dataflow, since usually …\nFrontier (in sys time) before which updates should not be …\nreturn a handle to the current time, will update when <code>as_of</code>…\nerror collector local to this <code>ComputeState</code>, useful for …\nthe time arrangement need to be expired after a certain …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nschedule all subgraph that need to run with time &lt;= <code>as_of</code> …\nit is important to use a deque to maintain the order of …\nArranged is a wrapper around <code>ArrangeHandler</code> that maintain …\nA collection, represent a collections of data that is …\nA bundle of the various ways a collection can be …\nA thread local error collector, used to collect errors …\nthe key <code>ScalarExpr</code> indicate how the keys(also a [<code>Row</code>]) …\nclone a collection, require a mutable reference to the …\nThis is useful for passively reading the new updates from …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nmaintain a list of readers for the arrangement for the …\nrepresent a stream of updates recv from this port\nCopy it’s future only updates, internally <code>Rc-ed</code> so it’…\nThis rule check all group by exprs, and make sure they are …\nrewrite <code>avg(&lt;expr&gt;)</code> function into …\nFind all column names in a plan\nThis is a placeholder for tumble_start and tumble_end …\nexpand tumble in aggr expr to tumble_start and tumble_end …\nmake sure everything in group by’s expr is in select\nexpand <code>avg(&lt;expr&gt;)</code> function into …\nexpand <code>tumble</code> in aggr expr to <code>tumble_start</code> and <code>tumble_end</code>, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nlift aggr’s composite aggr_expr to outer proj, and leave …\nschema of the plan\nelide the signature for now\nTo reuse existing code for parse sql, the sql is first …\nSNAFU context selector for the <code>Error::CacheRequired</code> variant\nSNAFU context selector for the <code>Error::CreateFlow</code> variant\nSNAFU context selector for the <code>Error::Datafusion</code> variant\nSNAFU context selector for the <code>Error::Datatypes</code> variant\nContains the error value\nThis error is used to represent all possible errors that …\nTODO(discord9): add detailed location of column\nSNAFU context selector for the <code>Error::Eval</code> variant\nSNAFU context selector for the <code>Error::External</code> variant\nSNAFU context selector for the <code>Error::FlowAlreadyExist</code> …\nSNAFU context selector for the <code>Error::FlowNotFound</code> variant\nSNAFU context selector for the <code>Error::InsertIntoFlow</code> …\nSNAFU context selector for the <code>Error::Internal</code> variant\nSNAFU context selector for the <code>Error::InvalidQuery</code> variant\nSNAFU context selector for the <code>Error::JoinTask</code> variant\nSNAFU context selector for the <code>Error::ListFlows</code> variant\nSNAFU context selector for the <code>Error::MetaClientInit</code> …\nSNAFU context selector for the <code>Error::NotImplemented</code> …\nContains the success value\nSNAFU context selector for the <code>Error::ParseAddr</code> variant\nSNAFU context selector for the <code>Error::Plan</code> variant\nResult type for flow module\nSNAFU context selector for the <code>Error::ShutdownServer</code> …\nSNAFU context selector for the <code>Error::StartServer</code> variant\nSNAFU context selector for the <code>Error::TableNotFoundMeta</code> …\nSNAFU context selector for the <code>Error::TableNotFound</code> variant\nSNAFU context selector for the <code>Error::Unexpected</code> variant\nSNAFU context selector for the …\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nthe outer message is the full error stack, and inner …\n<code>ToString::to_string</code>, but without panic on OOM.\nA batch of vectors with the same length but without …\nVector with diff to note the insert and delete\niterator for VectorDiff\nappend another batch to self\nPorting Datafusion scalar function to our scalar function …\ndescribe if corresponding rows in batch is insert or …\nError handling for expression evaluation.\nfilter the batch with given predicate\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis module contains the definition of functions that can …\n<code>Id</code> is used to identify a dataflow component in plan like …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ndefine MapFilterProject which is a compound operator that …\nDescribes an aggregation function and it’s input …\nScalar expressions.\nFunction signature, useful for type checking and function …\nSlices the <code>Batch</code>, returning a new <code>Batch</code>.\nGet batch from rows, will try best to determine data type\nThis module contains utility functions for expressions.\nA way to represent a scalar function that is implemented …\nThe input schema of the function\neval a list of expressions using input values\nEvaluate a batch of expressions using input values\nExtension contains mapping from function reference to …\nThe raw bytes encoded datafusion scalar function, due to …\nThe implementation of the function\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe input schema of the function\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe raw bytes encoded datafusion scalar function\nSNAFU context selector for the <code>EvalError::Arrow</code> variant\nSNAFU context selector for the <code>EvalError::CastValue</code> variant\nSNAFU context selector for the …\nSNAFU context selector for the <code>EvalError::DataType</code> variant\nSNAFU context selector for the <code>EvalError::Datafusion</code> …\nSNAFU context selector for the <code>EvalError::DivisionByZero</code> …\nEvalError is about errors happen on columnar evaluation\nSNAFU context selector for the <code>EvalError::External</code> variant\nSNAFU context selector for the <code>EvalError::Internal</code> variant\nSNAFU context selector for the <code>EvalError::InvalidArgument</code> …\nSNAFU context selector for the <code>EvalError::Optimize</code> variant\nSNAFU context selector for the <code>EvalError::Overflow</code> variant\ncan’t nest datatypes error because EvalError need to be …\nSNAFU context selector for the <code>EvalError::TryFromValue</code> …\nSNAFU context selector for the <code>EvalError::TypeMismatch</code> …\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nBinaryFunc is a function that takes two arguments. Also …\nAn iterator over the variants of BinaryFunc\nUnaryFunc is a function that takes one argument. Also …\nUnmaterializableFunc is a function that can’t be eval …\nVariadicFunc is a function that takes a variable number of …\nEvaluate the function with given values and expression\nEvaluate the function with given values and expression\nEvaluate the function with given values and expressions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a UnaryFunc from a string of the function name and …\nCreate a VariadicFunc from a string of the function name …\nCreate a UnmaterializableFunc from a string of the …\nchoose the appropriate specialization based on the input …\nGenerate binary function signature based on the function …\ntry it’s best to infer types from the input types and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReverse the comparison operator, i.e. <code>a &lt; b</code> becomes <code>b &gt; a</code>, …\nReturn the signature of the function\nReturn the signature of the function\nUse null type to ref to any type\nReturn the signature of the function\nGet the specialization of the binary function based on the …\nDummy id for query being explained\nAn identifier that refers to a global dataflow.\nGlobal id’s scope is in Current Flow node, and is …\nId is used to identify a dataflow component in plan like …\nAn identifier that refers to a local component of a …\nLocal id is used in local scope created by …\nSystem namespace.\nTransient namespace.\nUser namespace.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA compound operator that can be applied row-by-row.\nPredicates partitioned into temporal and non-temporal.\nA wrapper type which indicates it is safe to simply …\nAs the arguments to <code>Map</code>, <code>Filter</code>, and <code>Project</code> operators.\nGiven two mfps, return an mfp that applies one followed by …\nfind <code>now</code> in <code>predicates</code> and put them into lower/upper …\nLists input columns whose values are used in outputs.\nsimilar to [<code>MapFilterProject::evaluate_into</code>], just in …\nsimilar to [<code>MapFilterProject::evaluate_into</code>], just in …\nif <code>lower_bound &lt;= sys_time &lt; upper_bound</code>, return …\nPopulates <code>values</code> with <code>self.expressions</code> and tests …\nEvaluates the linear operator on a supplied list of datums.\nA sequence of expressions that should be appended to the …\nRetain only rows satisfying these predicates.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nget the mapping of old columns to new columns after the mfp\nThe expected number of input columns.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLike <code>MapFilterProject::as_map_filter_project</code>, but consumes …\nConvert the <code>MapFilterProject</code> into a safe evaluation plan. …\nTrue if the operator describes the identity transformation.\nIndicates if the planned <code>MapFilterProject</code> emits exactly …\nIndicates if the <code>MfpPlan</code> contains temporal predicates. …\nTODO(discord9): impl temporal filter later Expressions …\nAppend the result of evaluating expressions to each row.\nthe inner <code>MapFilterProject</code> that is safe to evaluate.\nNormal predicates to evaluate on <code>&amp;[Datum]</code> and expect …\nCreate a no-op operator for an input of a supplied arity.\nOptimize the <code>MapFilterProject</code> in place.\nThe number of columns expected in the output row.\nUpdate input column references, due to an input projection …\nSee <code>MapFilterProject::permute</code>.\nExpressions that must evaluate to <code>Datum::True</code> for the …\nRetain only the indicated columns in the presented order.\nA sequence of column identifiers whose data form the …\nExpressions that when evaluated upper-bound <code>MzNow</code>.\nDescribes an aggregation expression.\nAccumulators for aggregate functions that’s is …\nShould the aggregation be applied only to distinct results …\nAn expression which extracts from each row the input to …\nReturns the argument unchanged.\nConvert AggregateFunction into Flow’s AggregateExpr\nConvert list of <code>Measure</code> into Flow’s AggregateExpr\nNames the aggregation function.\nCalls <code>U::from(self)</code>.\nAccumulates values for the various types of accumulable …\nAccumulates values for the various types of accumulable …\nBool accumulator, used for <code>Any</code> <code>All</code> <code>Max/MinBool</code>\nAccumulates boolean values.\nAccumulates float values for sum over floating numbers.\nAccumulates float values.\nAccumulates a single <code>Ord</code>ed <code>Value</code>, useful for min/max …\nAccumulate Values that impl <code>Ord</code>\nAccumulates simple numeric values for sum over integer.\nAccumulates simple numeric values.\nThe accumulation of all non-NULL values observed.\nAccumulates non-special float values, i.e. not NaN, +inf, …\nThe number of <code>false</code> values observed.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCounts NaNs\nCounts -inf\ncreate a new accumulator from given aggregate function\nThe number of non-NULL values observed.\nCounts non-NULL values\nCounts +inf\nThe number of <code>true</code> values observed.\nExpect two <code>Diff</code> type values, one for <code>true</code> and one for <code>false</code>…\nExpect one <code>Decimal128</code> and one <code>Diff</code> type values. The …\nExpect first value to be <code>OrderedF64</code> and the rest four …\ntry to convert a vector of value into given aggregate …\ncompare type while ignore their precision, including …\nNull values are ignored\nsum ignore null\nmin/max try to find results in all non-null values, if all …\nAggregate functions that can be applied to a group of rows.\nAn iterator over the variants of AggregateFunc\nreturn output value and new accumulator state\nEval value, diff with accumulator\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>AggregateFunc</code> from a string of the function name …\nGenerate one match arm with optional arguments\nGenerate signature for each aggregate function\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nif this function is a <code>max</code>\nif this function is a <code>min</code>\nall concrete datatypes with precision types will be …\nA call to an unmaterializable function.\nA column of the input row\nConditionally evaluated expressions.\nA literal value. Extra type info to know original type …\nA scalar expression, which can be evaluated to a value.\nA scalar expression with a known type.\nCast the expression to a column reference if it is one.\nCast the expression to a literal if it is one.\nCall a binary function on this expression and another.\nCall a unary function on this expression.\nif expr contains function <code>Now</code>\nEval this expression with the given values.\nNOTE: this if then eval impl assume all given expr are …\nThe expression.\nextract lower or upper bound of <code>Now</code> for expr, where …\nBecause Substrait’s <code>And</code>/<code>Or</code> function is binary, but …\nReturns the argument unchanged.\nReturns the argument unchanged.\nAllow <code>deprecated</code> due to the usage of deprecated …\nConvert IfThen into Flow’s ScalarExpr\nConvert Substrait Rex into Flow’s ScalarExpr\nConvert ScalarFunction into Flow’s ScalarExpr\nReturns the set of columns that are referenced by <code>self</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if the expression is a column reference.\nReturn true if the expression is a literal.\nReturn true if the expression is a literal false.\nReturn true if the expression is a literal null.\nReturn true if the expression is a literal true.\nBuild a literal from value and type\nBuild a literal false\nBuild a literal null\nBuild a literal true\napply optimization to the expression, like flatten …\nRewrites column indices with their value in <code>permutation</code>.\nRewrites column indices with their value in <code>permutation</code>.\ntry to determine the type of the expression\nThe type of the expression.\nvisit post-order without stack call limit, but may cause …\ninvariant: the input args set inside this <code>DfScalarFunction</code> …\nGeneric function category\nFunction signature\nReturns the argument unchanged.\nReturns the argument unchanged.\nGeneric function\nthe input types, usually not great than two input arg\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOutput type\nFind lower bound for time <code>current</code> in given <code>plan</code> for the …\nFind the lower bound of time window in given <code>expr</code> and …\nThe flownode heartbeat task which sending …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA constant collection of rows.\nGet CDC data from an source, be it external reference to …\nA multiway relational equijoin, with fused map, filter, …\nCreate a temporary collection from given <code>value</code>, and make …\nMap, Filter, and Project operators. Chained together.\nTODO(discord9): support <code>TableFunc</code>（by define FlatMap that …\nReduce operator, aggregation by key assembled from …\nA plan for a dataflow component. But with type to indicate …\nAdds the contents of the input collections.\nAdd a new filter to the plan, will filter out the records …\nFind all the used collection in the plan\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert AggregateRel into Flow’s TypedPlan\nConvert Substrait Plan into Flow’s TypedPlan\nConvert Substrait Rel into Flow’s TypedPlan …\nGet the first input plan if exists\nGet mutable ref to the first input plan if exists\nGet nth expr using column ref\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ndirectly apply a mfp to the plan\nThe untyped plan.\nproject the plan to the given expressions\noutput type of the relation\nWhether to consolidate the output, e.g., cancel negated …\nThe input collection.\nThe input collection.\nAn ordered list of inputs that will be joined.\nThe input collections\nA plan for changing input records into key, value pairs.\nLinear operator to apply to each record.\nDetailed information about the implementation of the join.\nA plan for performing the reduce.\nDetermine if a given row should stay in the output. And …\nTODO(discord9): consider impl more join strategies\nA plan for the execution of a linear join.\nA plan for the execution of one stage of a linear join.\nApply a map filter project before output the row\nThe closure to apply to the concatenation of the key …\nA concluding filter to apply after the last stage.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAn initial closure to apply before any stages.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe key expressions to use for the lookup relation.\nThe index of the relation into which we will look up.\neach element in the outer vector will check if each expr …\nThe arrangement to use for the source relation, if any\nThe source relation from which we start the join.\nA <em>sequence</em> of stages to apply one after the other.\nThe key expressions to use for the stream relation.\nColumns to retain from the stream relation. These columns …\nPlan for computing only accumulable aggregations. …\nAccumulable plan for the execution of a reduction.\nInvariant: the output index is the index of the …\nPlan for not computing any aggregations, just determining …\nDescribe how to extract key-value pair from a <code>Row</code>\nTODO(discord9): def&amp;impl of Hierarchical aggregates(for …\nSame as <code>simple_aggrs</code> but for all of the <code>DISTINCT</code> …\naggregation expression\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate KeyValPlan from AggregateExpr and group_exprs\nAll of the aggregations we were asked to compute, stored …\nGet nth expr using column ref\nindex of aggr input among input row\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtract key from row\nCreate a new <code>AggrWithIndex</code>\nindex of aggr output among output row\nAll of the non-distinct accumulable aggregates. Each …\nExtract value from row\nFlow worker will try to at least accumulate this many rows …\nbroadcast channel capacity, can be important to memory …\nSystem-wide Record count difference type. Useful for …\nDefault type for a repr of changes to a collection.\nSystem-wide default duration type, in milliseconds\nRow with key-value pair, timestamp and diff\nA row is a vector of values.\nThe maximum capacity of the send buffer, to prevent the …\nSystem-wide default timestamp type, in milliseconds\nClear the row\nCreate an empty row\nextend the row with values from an iterator\nReturns the argument unchanged.\nGet the value at the given index\nThe inner vector of values\nCalls <code>U::from(self)</code>.\nCreates a consuming iterator, that is, one that moves each …\nReturns true if the Row contains no elements.\nReturns an iterator over the slice.\nReturns the number of elements in the row, also known as …\nCreate a row from a vector of values\npack a iterator of values into a row\nclear and return the inner vector\nunpack a row into a vector of values\nConvert a value that is or can be converted to Datetime to …\nThe name of a column in a <code>RelationDesc</code>.\nThe type of a <code>Value</code>\na set of column indices that are “keys” for the …\nA description of the shape of a relation.\nThe type of a relation.\nAdd a column to Key\nTrying to apply a mpf on current types, will return a new …\napply mfp, and also project col names for the projected …\nComputes the number of columns in the relation.\nComputes the number of columns in the relation.\nmark all the columns that are added automatically by flow, …\nindicate whose column form key\nThe type for each column, in order.\nConcatenates a <code>RelationDesc</code> onto the end of this …\nGets the index of the columns used when creating a default …\nConstructs a <code>RelationType</code> representing the relation with …\nConstructs a new <code>RelationDesc</code> that represents the empty …\nReturns the argument unchanged.\ncreate a new Key from a vector of column indices\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nget all columns in Key\nFinds a column by name.\nGets the name of the <code>i</code>th column.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn relation describe with column names\nReturn relation describe without column names\nTrue if Key is empty\nReturns an iterator over the columns in this relation.\nReturns an iterator over the names of the columns in this …\nReturns an iterator over the types of the columns in this …\nSets of indices that are “keys” for the collection.\ncreate a new Key\nConstructs a new <code>RelationType</code> from specified column types.\nConstructs a new <code>ColumnType</code> from a scalar type and a …\nConstructs a new <code>ColumnType</code> from a scalar type, with …\nConstructs a new <code>RelationDesc</code> from a <code>RelationType</code> and an …\nReturns true if this column can be null.\nWhether this datum can be null.\nRemove a column from Key\nThis method exists solely for the purpose of making …\nReturns the scalar type of this column.\nThe underlying scalar type (e.g., Int32 or String) of this …\nTrue if all columns in self are also in other\nTrue if any collection described by <code>self</code> could safely be …\noptionally indicate the column that is TIME INDEX\nConstructs a new <code>RelationDesc</code> from a <code>RelationType</code> and an …\nBuilds a new relation description with the column names …\nReturns the relation type underlying this relation …\nAppends a column with the specified name and type.\nAdds a new key for the relation. Also sorts the key …\nAdds a new key for the relation.\nAdds new keys for the relation. Also sorts the key indices.\nwill also remove time index from keys if it’s in keys\nwrapping flow node manager to avoid orphan rule with Arc&lt;…\n<code>FlownodeInstance</code> Builder\nThe flownode server instance.\nbuild <code>FlowWorkerManager</code>, note this doesn’t take …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nget all flow ids in this flownode\nonly used for health check\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ninit flownode builder\nrecover all flow tasks in this flownode in distributed …\nreceive a oneshot sender to send state size report\nIn Substrait, a function can be define by an u32 anchor, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the name of a function by it’s anchor\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\na simple macro to generate a not implemented error\ngenerate a plan error\nregister flow-specific functions to the query engine\nCreate a new FunctionExtensions from a list of …\n<code>ToString::to_string</code>, but without panic on OOM.\nfind out the column that should be time index in group …\nConvert <code>ScalarFunction</code> to corresponding Datafusion’s …\nReturn an <code>Expression</code>(wrapped in a [<code>FunctionArgument</code>]) that …\nrewrite ScalarFunction’s arguments to Columns 0..n so …\nref to <code>arrow_schema::datatype</code> for type name\nReturns the argument unchanged.\nConvert a Substrait literal into a Value and its …\nconvert a Substrait type into a ConcreteDataType\nCalls <code>U::from(self)</code>.\nTODO(discord9): this is copy from datafusion-substrait …\nA handler to the inner Arrangement, can be cloned and …\nSimply a type alias for ReadGuard of Arrangement\nSimply a type alias for WriteGuard of Arrangement\nA shared state of key-value pair for various state in …\nA batch of updates, arranged by key\nDetermine when should a key expire according to it’s …\nA spine of batches, arranged by timestamp TODO(discord9): …\nHandle the size report request, and send the report back\nApply updates into spine, with no respect of whether the …\nClone the handler, but keep all updates.\nClone the handler, but only keep the future updates.\nAdvance time to <code>now</code> and consolidate all older (<code>now</code> …\nReturn timestamp that should be expired by the time <code>now</code> by …\nEstimated size of the arrangement in heap size.\nExpression to get timestamp from key row\nA map from event timestamp to key, used for expire keys.\nManage the expire state of the arrangement.\nExtract event timestamp from key row.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ncreate a new handler from arrangement\nReturns the argument unchanged.\nIndicates whether the arrangement maintains a complete …\nGet current state of things.\nGet the expire duration of a key, if it’s expired by now.\nUpdate the event timestamp to key mapping.\nFind out the time of next update in the future that is the …\nGet the updates of the arrangement from the given range of …\nGet a estimate of heap size of a value\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndicates whether the arrangement has been modified since …\nDuration after which a key is considered expired, and will …\nGet the last compaction time.\nThe time that the last compaction happened, also known as …\nA name or identifier for the arrangement which can be used …\nQuery the size report, will timeout after one second if no …\nread lock the arrangement\nRemove expired keys from the state, and return an iterator …\nManages a collection of pending updates in a <code>BTreeMap</code> …\nSplit the batch at <code>split_ts</code> into two parts.\nSplit spine off at <code>split_ts</code>, and return the spine that’s …\nExpire keys in now that are older than expire_time, …\nwrite lock the arrangement")