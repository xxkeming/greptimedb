searchState.loadedDescShard("promql", 0, "SNAFU context selector for the <code>Error::ColumnNotFound</code> …\nSNAFU context selector for the <code>Error::DataFusionPlanning</code> …\nSNAFU context selector for the <code>Error::Deserialize</code> variant\nSNAFU context selector for the <code>Error::EmptyRange</code> variant\nContains the error value\nSNAFU context selector for the <code>Error::IllegalRange</code> variant\nContains the success value\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmpty source plan that generate record batch with two …\n<code>HistogramFold</code> will fold the conventional (non-native) …\nManipulate the input record batch to make it suitable for …\nTime series manipulator for range function.\n<code>ScalarCalculate</code> is the custom logical plan to calculate …\nAssume the input stream is ordered on the tag columns.\nNormalize the input record batch. Notice that for …\nA special kind of <code>UNION</code>(<code>OR</code> in PromQL) operator, for PromQL …\nExpected output batch size\nInclude time index\nThe columns to compare for equality. TIME INDEX is …\nA optional column for validating staleness\nIndex for field column in the schema of input.\nIndex of buffered batches to start inspect next time.\nThis stream only generate one record batch at the first …\nName of the <code>le</code> column. It’s a special column in …\nIndex for <code>le</code> column in the schema of input.\nColumns need not folding. This indices is based on input …\nShared the <code>RandomState</code> for the hashing algorithm\nSchema of the output record batch\nSchema of the output record batch\nSchema of the output record batch\nSchema that only contains the time index column. This is …\nSchema that only contains the time index column. This is …\nSchema that only contains the time index column. This is …\nEmpty source plan that generate record batch with two …\nBuild a schema that only contains <strong>millisecond</strong> timestamp …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis stream only generate one record batch at the first …\nSchema of the output record batch\nSchema of the output record batch\nSchema of the output record batch\nSchema that only contains the time index column. This is …\nSchema that only contains the time index column. This is …\nSchema that only contains the time index column. This is …\n<code>HistogramFold</code> will fold the conventional (non-native) …\nExpected output batch size\nTransform the schema\nGenerate a group of empty MutableVectors from the output …\nEvaluate the field column and return the result\nIndex for field column in the schema of input.\nFind the first <code>+Inf</code> which indicates the end of the bucket …\nFold record batches from input buffer and put to output …\nThe inner most <code>Result</code> is for <code>poll_next()</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nName of the <code>le</code> column. It’s a special column in …\nIndex for <code>le</code> column in the schema of input.\nColumns need not folding. This indices is based on input …\nReturn all the PhysicalExpr of tag columns in order.\nCompute result from output buffer\nManipulate the input record batch to make it suitable for …\nA optional column for validating staleness\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper function to apply “take” on record batch.\nNormalize the input record batch. Notice that for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTime series manipulator for range function.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>ScalarCalculate</code> is the custom logical plan to calculate …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of this custom plan\ncreate a new <code>ScalarCalculate</code> plan\nwith format <code>(ts_index, field_index)</code>\nCreate a new execution plan from ScalarCalculate\nAssume the input stream is ordered on the tag columns.\nReturn the position to cut buffer. None implies the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIndex of buffered batches to start inspect next time.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe result is taken\nALL input batches and its hash table\nSimple future state for HashedData\nThe result is not ready\nThe result is ready\nA special kind of <code>UNION</code>(<code>OR</code> in PromQL) operator, for PromQL …\nOutput batch.\nInclude time index\nThe columns to compare for equality. TIME INDEX is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe indices of the columns to be hashed.\nHash table for all input batches. The key is hash value, …\nUtility function to interleave batches. Based on interleave\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nShared the <code>RandomState</code> for the hashing algorithm\nUtility function to take rows from a record batch. Based …\nRemove rows that hash value present in the input record …\nabsent_over_time returns an empty vector if the range …\nThe average value of all points in the specified interval.\nused to count the number of value changes that occur …\nThe count of all values in the specified interval.\nThere are 3 variants of smoothing functions:\nThe <code>funcIdelta</code> in Promql, from …\nThe most recent point value in specified interval.\nThe maximum value of all points in the specified interval.\nThe minimum value of all points in the specified interval.\nthe value 1 for any series in the specified interval.\nused to count the number of times the time series starts …\nthe population standard deviation of the values in the …\nthe population standard variance of the values in the …\nThe sum of all values in the specified interval.\nImplementation of <code>changes</code> in PromQL. Refer to the original …\ncompensation(Kahan) summation algorithm - a technique for …\nImplementation of <code>deriv</code> in PromQL. Refer to the original …\nImplementations of <code>rate</code>, <code>increase</code> and <code>delta</code> functions in …\nImplementation of <code>holt_winters</code> in PromQL. Refer to the …\nlinear_regression performs a least-square linear …\nImplementation of <code>predict_linear</code> in PromQL. Refer to the …\nRange duration in millisecond\nRange duration in millisecond\nRange duration in millisecond\nImplementation of <code>reset</code> in PromQL. Refer to the original …\nDuration. The second param of (…\nabsent_over_time returns an empty vector if the range …\nThe average value of all points in the specified interval.\nThe count of all values in the specified interval.\nThe most recent point value in specified interval.\nThe maximum value of all points in the specified interval.\nThe minimum value of all points in the specified interval.\nthe value 1 for any series in the specified interval.\nthe population standard deviation of the values in the …\nthe population standard variance of the values in the …\nThe sum of all values in the specified interval.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nused to count the number of value changes that occur …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPart of the <code>extrapolatedRate</code> in Promql, from …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstructor. Other public usage should use scalar_udf() …\nRange duration in millisecond\nRange duration in millisecond\nRange duration in millisecond\nRange duration in millisecond\nThere are 3 variants of smoothing functions:\nReturns the argument unchanged.\nRefer to …\nCalls <code>U::from(self)</code>.\nThe <code>funcIdelta</code> in Promql, from …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDuration. The second param of (…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRefer to …\nused to count the number of times the time series starts …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCounter for the number of series processed per query.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn compound logical “array” type. Represent serval …\nBuild datatype of wrapped RangeArray on given value type.\nChange the field’s datatype to the type after processed …\nReturns the argument unchanged.\nConstruct RangeArray from given range without checking its …\nCalls <code>U::from(self)</code>.\nReturn the underlying Arrow’s DictionaryArray. Notes the …")